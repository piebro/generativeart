<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Templet Tool</title>
    <script src="../../lib/canvas2svg.js"> </script>
    <script src="../../lib/gat-0.3.js"> </script>
    <script src="../../lib/opentype.min.js"> </script>
    <link rel="stylesheet" type="text/css" href="../../lib/tool-gui.css">
</head>

<style>

.multiselect {
  width: 100px;
}

.selectBox {
  position: relative;
}

.selectBox select {
  width: 100%;
  
}

.overSelect {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
}

#checkboxes {
  display: none;
  border: 1px #dadada solid;
}

#checkboxes label {
  display: block;
}

#checkboxes label:hover {
  background-color: #1e90ff;
}

</style>

<body>

<div class=ui-div id="ui-div">
  
  <br><label class=ui-label>font</label><br>
  <select class=item id=font onchange="fontChange()">
    <option selected="select">Roboto-Thin</option>
    <option>Roboto-Black</option>
  </select>
  <input id="file-upload" type="file" style="display: none"/>

  <br><label class=ui-label>canvas size</label><br>
  <input type="text" id=canvas-size class="item ui-input" onchange="redraw()" value="1000,600">

  <br><label class=ui-label>text</label><br>
  <textarea class=item id=text rows="8" onchange="redraw()">Some Nice Text</textarea>

  <br>
  <div class="selectBox item ui-label" onclick="showCheckboxes()">
    <select class="item ui-label">
      <option>Deformations</option>
    </select>
    <div class="overSelect"></div>
  </div>
  <div id="checkboxes" >
    <label for="one" class="">
      <input type="checkbox" id="one" />First checkbox</label>
  </div>

  <br><label class=ui-label>text alignment</label><br>
  <select class=item id=text-alignment onchange="redraw()">
    <option>left</option>
    <option selected="selected">center</option>
    <option>right</option>
  </select>

  <br><label class=ui-label>line spacing</label><br>
  <input type="text" id=line-spacing class="item ui-input" onchange="redraw()" value="0.0">

  <br><label class=ui-label>border</label><br>
  <input type="text" id=border class="item ui-input" onchange="redraw()" value="0.2">

  <br><label class=ui-label>creazyness</label><br>
  <input type="text" id=creazyness class="item ui-input" onchange="redraw()" value="0.2">
  

  <br><br><label for="button" class="ui-label, ui-file-upload">
      Shuffel
  </label>
  <button style="display: none" id="button" onclick="redraw()"></button>

  


</div> 

<div class=canvas-div id="canvas-div"></div>
  

<script>

//TODO: better gui, with drop down stuff

var expanded = false;

function showCheckboxes() {
  var checkboxes = document.getElementById("checkboxes");
  if (!expanded) {
    checkboxes.style.display = "block";
    expanded = true;
  } else {
    checkboxes.style.display = "none";
    expanded = false;
  }
}

// asci text: http://patorjk.com/

const centeredCanvasObj = new gat.CenteredElement("canvas", [1000,600], document.getElementById("canvas-div"));
centeredCanvasObj.element.style.backgroundColor="#EEEEEE";
const redraw = draw.bind(null, centeredCanvasObj.element.getContext("2d"));

let RobotoFont;
let typingTimer;
let currentFont;


window.addEventListener("keyup", (event) => {
  if (document.activeElement.tagName == "TEXTAREA" || document.activeElement.tagName == "INPUT") {
    clearTimeout(typingTimer);
    typingTimer = setTimeout(redraw, 400);
  } else {
    if(event.keyCode == 83){
      const ctx = new C2S(...centeredCanvasObj.size);
      draw(ctx)
      gat.downloadText("strange-text.svg", ctx.getSerializedSvg());
    }
  }
});


fontChange();

function fontChange(){
  if(currentFont != document.getElementById('font').value){
    currentFont = document.getElementById('font').value
    opentype.load('/data-and-scripts/fonts/' + currentFont + '.ttf', function(err, font) {
      if (err) {
        alert('Font could not be loaded: ' + err);
      } else {
        RobotoFont = font;
        redraw()
      }
    });
  }
}


function draw(ctx){
  if (ctx.clearRect != undefined) ctx.clearRect(0, 0, ...centeredCanvasObj.size);
  ctx.beginPath();
  ctx.lineJoin="round";
  ctx.lineCap="round";
  ctx.lineWidth=3;
  

  const tempCanvasSize = document.getElementById("canvas-size").value.split(",").map(value => parseInt(value));

  centeredCanvasObj.size = [centeredCanvasObj.size[0], centeredCanvasObj.size[0] * tempCanvasSize[1]/tempCanvasSize[0]];


  const textArray = makeTextCreazy(document.getElementById("text").value).split("\n")
  const textAlignment = document.getElementById("text-alignment").value;
  const lineSpacing = parseFloat(document.getElementById("line-spacing").value);
  const borderAlpha = parseFloat(document.getElementById("border").value);
  const creazyness = parseFloat(document.getElementById("creazyness").value);
  

  const canvasSize = centeredCanvasObj.size;

  const bb = getBoundingBox(textArray, lineSpacing)
  const maxScaleWidth = canvasSize[0]/bb.maxWidth;
  const maxScaleHeight = canvasSize[1]/bb.height;
  const scale = Math.min(maxScaleWidth, maxScaleHeight) * (1-borderAlpha);

  const fixedTranslateX = borderAlpha/2 * canvasSize[1];
  const fixedTranslateY = (canvasSize[1]-scale*bb.height)/2

  for(let i=0; i<textArray.length; i++){
    let translateX = fixedTranslateX;
    if(textAlignment=="center"){
      translateX = (canvasSize[0] - bb.width[i]*scale)/2;
    } else if(textAlignment=="right"){
      translateX = canvasSize[0] - bb.width[i]*scale
    }
    let translateY = fixedTranslateY + (i+1)*scale + i * lineSpacing * scale;

    let tempXOffset = 0;
    for(let j=0; j<textArray[i].length; j++){
      const char = textArray[i][j];
      const cWidth = RobotoFont.getAdvanceWidth(char, 1) * scale;
      const cHeight = scale;
      const cMid = [translateX + tempXOffset + cWidth/2, translateY - cHeight*6/17] 

      

      //ctx.rect(cMid[0]-10, cMid[1]-10, 20, 20)
      //ctx.stroke()

      

      path = RobotoFont.getPath(char, translateX + tempXOffset, translateY, scale);
      if(creazyness >= 0){
        path = deformPath(creazyness, path, cMid);
      }
      
      //
      //
      //pathMirrorY(path, cMid);
      //pathTranslate(path, 100, 100)
      //pathScale(path, cMid, 1.5, 1.5)
      //console.log(path)
      path.draw(ctx);

      tempXOffset += cWidth;
    }
  }  
}

function deformPath(creazyness, path, cMid){
  if(creazyness>0.1){
    if(Math.random()>1-(creazyness/2)*0.7){
      pathMirrorX(path, cMid);
    }
  }
  
  if(creazyness>0.2){
    const rotation = (creazyness-0.2) * (Math.random()-0.5) * 0.9 * Math.PI;
    pathRotate(path, cMid, rotation);
  }
  

  
  
  return path
}

//operatione: übereinander, doppelt

function pathRotate(path, mid, angle){
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  for(let c of path.commands){
    if(c.type == "Z") continue
    const centeredX = (c.x-mid[0]);
    const centeredY = (c.y-mid[1]);
    c.x = centeredX*cos - centeredY*sin + mid[0];
    c.y = centeredX*sin + centeredY*cos + mid[1];
    if(c.type == "Q"){
      const centeredX1 = (c.x1-mid[0]);
      const centeredY1 = (c.y1-mid[1]);
      c.x1 = centeredX1*cos - centeredY1*sin + mid[0];
      c.y1 = centeredX1*sin + centeredY1*cos + mid[1];
    }
  }
}

function pathMirrorY(path, mid){
  pathScale(path, mid, 1, -1);
}

function pathMirrorX(path, mid){
  pathScale(path, mid, -1, 1);
}

function pathScale(path, mid, sx, sy){
  for(let c of path.commands){
    if(c.type == "Z") continue
    c.x = (c.x-mid[0])*sx + mid[0];
    c.y = (c.y-mid[1])*sy + mid[1];
    if(c.type == "Q"){  
      c.x1 = (c.x1-mid[0])*sx + mid[0];
      c.y1 = (c.y1-mid[1])*sy + mid[1];
    }
  }
}

function pathTranslate(path, x, y){
  for(let c of path.commands){
    if(c.type == "Z") continue
    c.x += x;
    c.y += y;
    if(c.type == "Q"){  
      c.x1 += x;
      c.y1 += y;
    }
  }
}

function getBoundingBox(textArray, lineSpacing){
  let width = [];
  let height = lineSpacing*(textArray.length-1) + textArray.length + 0.5;
  let maxWidth = 0;

  for(let text of textArray){
    const tempWidth = RobotoFont.getAdvanceWidth(text, 1);
    width.push(tempWidth);
    if(maxWidth < tempWidth){
      maxWidth = tempWidth;
    }
  }

  return {height, width, maxWidth};
}

function makeTextCreazy(text){
  
  let newText = "";
  for(let i in text){
    const newCharChoice = textmap[text[i]];
    if(newCharChoice != undefined){
      const ranIndex = Math.floor(Math.random() * newCharChoice.length)
      newText += newCharChoice[ranIndex]
    } else {
      newText += text[i];
    }
  }
  console.log(newText)
  return newText;
}

const textmap = {
  "A": "ĂĄẪẲΛǺДѦ∆",
  "a": "ªąặẵǻάҩ",
  "B": "βв",
  "b": "ЪЬҍБЂҕ",
  "C": "ÇČҀҪ",
  "c": "ҫ©¢çċςҁ",
  "D": "ĎĐ",
  "d": ":đďðδԂԃ₫∂",
  "E": "ĒΞ€ξЁỆԐЄ",
  "e": "ëĕęҿễệ℮",
  "F": "ҒӺ₣",
  "f": "ſƒ∫",
  "G": "ĞĢԌ",
  "g": "ğġģ",
  "H": "ĦҤԊӇ",
  "h": "ħЋђ",
  "I": "¦ľĺłĪЇΊ",
  "i": "¡ĭΐỉị",
  "J": "ĮĴ",
  "j": "įĵǰ₺",
  "K": "ӃҚҜҞҠ",
  "k": "ķӄқҝҟҡ",
  "L": "ŁĽĿĹ₤",
  "l": "ℓϑ",
  "M": "ΣҦӍḾ",
  "m": "₼ҧḿ",
  "N": "ŊΠйЉҊӅӢӤ₦ѝ∏",
  "n": "ԉŉŋήπпⁿԓ",
  "O": "¤ǾΘθѺФỞӪ",
  "o": "ӫŏōơǿσѻỗộỡ",
  "P": "¶₱Ҏ₽",
  "p": "Þþρφҏ",
  "Q": "ΏΩ",
  "q": "q",
  "R": "®₹ŘԄԆ",
  "r": "ŗřґӷѓ",
  "S": "§ŞŠȘ",
  "s": "śŝşšș",
  "T": "ŢŦȚτҬԎ",
  "t": "ţŧ†",
  "U": "ŬŲҴỬ",
  "u": "ửựữµūŭųҵứ",
  "V": "ѴѶ",
  "v": "ύϋѷΰ",
  "W": "ѠЩѼѾẄ₩",
  "w": "ŵѡѽѿщẅϖ",
  "X": "ҖӜӼӾӁ",
  "x": "ӽӿ×җӝӂ",
  "Y": "¥ŸУΨϒӋӴҰҸỴӰ",
  "y": "ӯӌÿѱλγӵүұҷҹџў",
  "Z": "ŹŻζ",
  "z": "żžӡ",
  "?": "¿�",
  "!": "ļỊ!",
  ".": "•‧",
  ":": "‥",
  "*": "˳̣̀́̃̉̏ ҂҃҄҅҆҈҉ ˜΅‡…ѪѬ"
  
}



</script>


</body>
</html>
